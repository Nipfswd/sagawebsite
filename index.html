<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Half-3D Genshin-Like Mini Demo with Restart</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; background: #222;
    font-family: Arial, sans-serif;
    -webkit-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
  }
  canvas {
    display: block;
    background: #555;
  }
  #joystick {
    position: fixed; 
    bottom: 30px; 
    left: 30px; 
    width: 150px; 
    height: 150px; 
    background: rgba(100, 100, 100, 0.3); 
    border-radius: 50%; 
    touch-action: none;
    user-select: none;
    z-index: 10;
  }
  #joystick-knob {
    position: absolute; 
    top: 50%; 
    left: 50%; 
    width: 60px; 
    height: 60px; 
    background: rgba(200, 200, 200, 0.7); 
    border-radius: 50%; 
    transform: translate(-50%, -50%);
    transition: background 0.3s;
  }
  #btn-attack {
    position: fixed; 
    bottom: 40px; 
    right: 40px; 
    width: 80px; 
    height: 80px; 
    border-radius: 50%; 
    background: rgba(255, 0, 0, 0.6); 
    border: none; 
    font-size: 32px; 
    color: white;
    user-select: none;
    z-index: 10;
  }
  #btn-attack:active {
    background: rgba(255, 0, 0, 0.9);
  }
  #restart-btn {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #00aaff;
    border: none;
    border-radius: 12px;
    color: white;
    font-size: 28px;
    padding: 20px 40px;
    cursor: pointer;
    display: none;
    z-index: 20;
  }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="joystick">
  <div id="joystick-knob"></div>
</div>

<button id="btn-attack">⚔️</button>
<button id="restart-btn">Restart</button>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const restartBtn = document.getElementById('restart-btn');

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  function isoProject(x, y, z=0) {
    return {
      x: (x - y) * Math.sqrt(3)/2,
      y: (x + y)/2 - z
    };
  }

  // Player object
  const player = {
    x: 0,
    y: 0,
    z: 0,
    size: 50,
    color: '#00aaff',
    speed: 3,
    attackColor: '#ff5500',
    isAttacking: false,
    attackDuration: 300,
    attackTimer: 0,
    facing: 0
  };

  // Enemy constructor
  function Enemy(x,y) {
    this.x = x;
    this.y = y;
    this.z = 0;
    this.size = 40;
    this.color = '#aa0000';
    this.health = 5;
    this.alive = true;
    this.lastDamageTime = 0;
  }

  // Store initial enemies for reset
  const initialEnemies = [
    new Enemy(5, 5),
    new Enemy(-5, 3),
    new Enemy(2, -4)
  ];

  let enemies = initialEnemies.map(e => Object.assign(Object.create(Object.getPrototypeOf(e)), e));

  // Controls
  const joystick = document.getElementById('joystick');
  const knob = document.getElementById('joystick-knob');
  const attackBtn = document.getElementById('btn-attack');

  const maxDistance = 50;
  let dragging = false;
  let keys = { w: false, a: false, s: false, d: false, attack: false };

  function updateKeys(dx, dy) {
    keys.w = keys.a = keys.s = keys.d = false;
    const distance = Math.sqrt(dx*dx + dy*dy);
    if(distance < 10) return;
    const angle = Math.atan2(dy, dx);

    if(angle < -Math.PI/4 && angle > -3*Math.PI/4) keys.w = true;
    if(angle > Math.PI/4 && angle < 3*Math.PI/4) keys.s = true;
    if(angle > 3*Math.PI/4 || angle < -3*Math.PI/4) keys.a = true;
    if(angle > -Math.PI/4 && angle < Math.PI/4) keys.d = true;

    player.facing = angle;
  }

  joystick.addEventListener('touchstart', e => { e.preventDefault(); dragging = true; });
  joystick.addEventListener('touchmove', e => {
    if(!dragging) return;
    e.preventDefault();
    const touch = e.targetTouches[0];
    let rect = joystick.getBoundingClientRect();
    let dx = touch.clientX - (rect.left + rect.width/2);
    let dy = touch.clientY - (rect.top + rect.height/2);
    const dist = Math.sqrt(dx*dx + dy*dy);
    if(dist > maxDistance) {
      dx = dx / dist * maxDistance;
      dy = dy / dist * maxDistance;
    }
    knob.style.transform = `translate(${dx}px, ${dy}px)`;
    updateKeys(dx, dy);
  });
  joystick.addEventListener('touchend', e => {
    e.preventDefault();
    dragging = false;
    knob.style.transform = 'translate(-50%, -50%)';
    keys.w = keys.a = keys.s = keys.d = false;
  });

  attackBtn.addEventListener('touchstart', e => {
    e.preventDefault();
    keys.attack = true;
    attackBtn.style.background = 'rgba(255, 0, 0, 0.9)';
  });
  attackBtn.addEventListener('touchend', e => {
    e.preventDefault();
    keys.attack = false;
    attackBtn.style.background = 'rgba(255, 0, 0, 0.6)';
  });

  function isNear(obj1, obj2, range) {
    const dx = obj1.x - obj2.x;
    const dy = obj1.y - obj2.y;
    const dz = obj1.z - obj2.z;
    return Math.sqrt(dx*dx + dy*dy + dz*dz) < range;
  }

  function drawDiamond(x, y, size, color, shadow=false) {
    ctx.save();
    ctx.translate(x, y);
    if(shadow) {
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.moveTo(0, size/2);
      ctx.lineTo(size/2, 0);
      ctx.lineTo(0, -size/2);
      ctx.lineTo(-size/2, 0);
      ctx.closePath();
      ctx.fill();
    }
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(0, size/2);
    ctx.lineTo(size/2, 0);
    ctx.lineTo(0, -size/2);
    ctx.lineTo(-size/2, 0);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawPlayer() {
    const pos = isoProject(player.x, player.y, player.z);
    const screenX = canvas.width/2 + pos.x;
    const screenY = canvas.height/2 + pos.y - player.size/4;

    drawDiamond(screenX + 10, screenY + 10, player.size * 0.6, 'rgba(0,0,0,0.3)', true);

    ctx.save();
    ctx.translate(screenX, screenY);
    ctx.rotate(player.facing);
    ctx.fillStyle = player.isAttacking ? player.attackColor : player.color;

    ctx.beginPath();
    ctx.moveTo(0, player.size/2);
    ctx.lineTo(player.size/2, 0);
    ctx.lineTo(0, -player.size/2);
    ctx.lineTo(-player.size/2, 0);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(0, 0, player.size/6, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawEnemy(enemy) {
    if(!enemy.alive) return;
    const pos = isoProject(enemy.x, enemy.y, enemy.z);
    const screenX = canvas.width/2 + pos.x;
    const screenY = canvas.height/2 + pos.y - enemy.size/4;

    drawDiamond(screenX + 10, screenY + 10, enemy.size * 0.6, 'rgba(0,0,0,0.3)', true);

    ctx.save();
    ctx.translate(screenX, screenY);
    ctx.fillStyle = enemy.color;

    ctx.beginPath();
    ctx.moveTo(0, enemy.size/2);
    ctx.lineTo(enemy.size/2, 0);
    ctx.lineTo(0, -enemy.size/2);
    ctx.lineTo(-enemy.size/2, 0);
    ctx.closePath();
    ctx.fill();

    // Health bar
    ctx.fillStyle = 'red';
    ctx.fillRect(-enemy.size/2, -enemy.size/2 - 10, enemy.size, 5);
    ctx.fillStyle = 'lime';
    ctx.fillRect(-enemy.size/2, -enemy.size/2 - 10, enemy.size * (enemy.health / 5), 5);

    ctx.restore();
  }

  const enemyDamageCooldown = 500;

  // Reset game state
  function resetGame() {
    player.x = 0;
    player.y = 0;
    player.z = 0;
    player.isAttacking = false;
    player.color = '#00aaff';
    enemies = initialEnemies.map(e => Object.assign(Object.create(Object.getPrototypeOf(e)), e));
    restartBtn.style.display = 'none';
  }

  restartBtn.addEventListener('click', () => {
    resetGame();
  });

  function gameLoop(timestamp) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Move player
    if(keys.w) player.y -= player.speed;
    if(keys.s) player.y += player.speed;
    if(keys.a) player.x -= player.speed;
    if(keys.d) player.x += player.speed;

    // Attack handling
    if(keys.attack && !player.isAttacking) {
      player.isAttacking = true;
      player.attackTimer = timestamp;
    }

    if(player.isAttacking) {
      if(timestamp - player.attackTimer < player.attackDuration) {
        // attacking state
        player.color = player.attackColor;
        enemies.forEach(enemy => {
          if(enemy.alive && isNear(player, enemy, (player.size + enemy.size)/2 + 10)) {
            if(timestamp - enemy.lastDamageTime > enemyDamageCooldown) {
              enemy.health--;
              enemy.lastDamageTime = timestamp;
              if(enemy.health <= 0) {
                enemy.alive = false;
              }
            }
          }
        });
      } else {
        player.isAttacking = false;
        player.color = '#00aaff';
      }
    }

    // Check if all enemies dead -> show restart button
    if(enemies.every(e => !e.alive)) {
      restartBtn.style.display = 'block';
    }

    enemies.forEach(drawEnemy);
    drawPlayer();

    requestAnimationFrame(gameLoop);
  }

  resetGame();
  requestAnimationFrame(gameLoop);

})();
</script>

</body>
</html>
