<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Mobile Friendly Genshin-Like Mini Demo with Enemy Attacks</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; background: #222;
    font-family: Arial, sans-serif;
    -webkit-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
  }
  canvas {
    display: block;
    background: #555;
  }
  #joystick {
    position: fixed; 
    bottom: 30px; 
    left: 30px; 
    width: 150px; 
    height: 150px; 
    background: rgba(100, 100, 100, 0.3); 
    border-radius: 50%; 
    touch-action: none;
    user-select: none;
    z-index: 10;
  }
  #joystick-knob {
    position: absolute; 
    top: 50%; 
    left: 50%; 
    width: 60px; 
    height: 60px; 
    background: rgba(200, 200, 200, 0.7); 
    border-radius: 50%; 
    transform: translate(-50%, -50%);
    transition: background 0.3s;
  }
  #btn-attack {
    position: fixed; 
    bottom: 40px; 
    right: 40px; 
    width: 80px; 
    height: 80px; 
    border-radius: 50%; 
    background: rgba(255, 0, 0, 0.6); 
    border: none; 
    font-size: 32px; 
    color: white;
    user-select: none;
    z-index: 10;
  }
  #btn-attack:active {
    background: rgba(255, 0, 0, 0.9);
  }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="joystick">
  <div id="joystick-knob"></div>
</div>

<button id="btn-attack">⚔️</button>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  const player = {
    x: canvas.width / 2,
    y: canvas.height / 2,
    size: 50,
    color: '#00aaff',
    speed: 5,
    attackColor: '#ff5500',
    isAttacking: false,
    attackDuration: 300,
    attackTimer: 0,
    maxHealth: 10,
    health: 10,
    alive: true,
  };

  const joystick = document.getElementById('joystick');
  const knob = document.getElementById('joystick-knob');
  const attackBtn = document.getElementById('btn-attack');

  const maxDistance = 50;
  let dragging = false;
  let keys = { w: false, a: false, s: false, d: false, attack: false };

  const enemySize = 40;
  const enemySpeed = 1.2;
  const enemyRespawnTime = 3000; // 3 seconds
  const enemyMaxHealth = 3;
  const enemyAttackDamage = 1;
  const enemyAttackCooldown = 1000; // 1 second between attacks
  const enemyAttackRange = 60; // range where enemy attacks player

  const enemies = [];
  const enemyCount = 5;

  function randomPosition() {
    return {
      x: Math.random() * (canvas.width - enemySize) + enemySize / 2,
      y: Math.random() * (canvas.height - enemySize) + enemySize / 2
    };
  }

  for(let i = 0; i < enemyCount; i++) {
    enemies.push({
      x: randomPosition().x,
      y: randomPosition().y,
      size: enemySize,
      color: 'red',
      alive: true,
      respawnTimer: 0,
      health: enemyMaxHealth,
      dirX: Math.random() < 0.5 ? -1 : 1,
      dirY: Math.random() < 0.5 ? -1 : 1,
      lastAttackTime: 0
    });
  }

  function updateKeys(dx, dy) {
    keys.w = keys.a = keys.s = keys.d = false;
    const distance = Math.sqrt(dx*dx + dy*dy);
    if(distance < 10) return;
    const angle = Math.atan2(dy, dx);
    if(angle < -Math.PI/4 && angle > -3*Math.PI/4) keys.w = true;
    if(angle > Math.PI/4 && angle < 3*Math.PI/4) keys.s = true;
    if(angle > 3*Math.PI/4 || angle < -3*Math.PI/4) keys.a = true;
    if(angle > -Math.PI/4 && angle < Math.PI/4) keys.d = true;
    if(angle > -Math.PI/4 && angle < Math.PI/4) keys.d = true;
    if(angle < -Math.PI/4 && angle > -3*Math.PI/4) keys.w = true;
    if(angle > Math.PI/4 && angle < 3*Math.PI/4) keys.s = true;
    if(angle > 3*Math.PI/4 || angle < -3*Math.PI/4) keys.a = true;
  }

  joystick.addEventListener('touchstart', e => {
    e.preventDefault();
    dragging = true;
  });

  joystick.addEventListener('touchmove', e => {
    if(!dragging) return;
    e.preventDefault();
    const touch = e.targetTouches[0];
    let rect = joystick.getBoundingClientRect();
    let dx = touch.clientX - (rect.left + rect.width/2);
    let dy = touch.clientY - (rect.top + rect.height/2);
    const dist = Math.sqrt(dx*dx + dy*dy);
    if(dist > maxDistance) {
      dx = dx / dist * maxDistance;
      dy = dy / dist * maxDistance;
    }
    knob.style.transform = `translate(${dx}px, ${dy}px)`;
    updateKeys(dx, dy);
  });

  joystick.addEventListener('touchend', e => {
    e.preventDefault();
    dragging = false;
    knob.style.transform = 'translate(-50%, -50%)';
    keys.w = keys.a = keys.s = keys.d = false;
  });

  attackBtn.addEventListener('touchstart', e => {
    e.preventDefault();
    keys.attack = true;
    attackBtn.style.background = 'rgba(255, 0, 0, 0.9)';
  });
  attackBtn.addEventListener('touchend', e => {
    e.preventDefault();
    keys.attack = false;
    attackBtn.style.background = 'rgba(255, 0, 0, 0.6)';
  });

  function isNear(a, b, distance) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return Math.sqrt(dx*dx + dy*dy) < distance;
  }

  function drawHealthBar(x, y, width, height, current, max, color) {
    ctx.fillStyle = 'black';
    ctx.fillRect(x, y, width, height);
    ctx.fillStyle = color;
    const healthWidth = (current / max) * width;
    ctx.fillRect(x, y, healthWidth, height);
  }

  function gameLoop(timestamp) {
    if(!player.alive) {
      // Game over screen
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'white';
      ctx.font = '48px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2);
      return; // stop game loop
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Move player
    if(keys.w) player.y -= player.speed;
    if(keys.s) player.y += player.speed;
    if(keys.a) player.x -= player.speed;
    if(keys.d) player.x += player.speed;

    // Keep player inside canvas
    player.x = Math.max(player.size/2, Math.min(canvas.width - player.size/2, player.x));
    player.y = Math.max(player.size/2, Math.min(canvas.height - player.size/2, player.y));

    // Handle player attack
    if(keys.attack && !player.isAttacking) {
      player.isAttacking = true;
      player.attackTimer = timestamp;
      enemies.forEach(enemy => {
        if(enemy.alive && isNear(player, enemy, (player.size + enemy.size) / 2 + 10)) {
          enemy.health--;
          if(enemy.health <= 0) {
            enemy.alive = false;
            enemy.respawnTimer = timestamp + enemyRespawnTime;
          }
        }
      });
    }

    if(player.isAttacking) {
      if(timestamp - player.attackTimer < player.attackDuration) {
        player.color = player.attackColor;
      } else {
        player.isAttacking = false;
        player.color = '#00aaff';
      }
    }

    // Update and draw enemies
    enemies.forEach(enemy => {
      if(!enemy.alive) {
        // Check respawn
        if(timestamp > enemy.respawnTimer) {
          enemy.alive = true;
          enemy.health = enemyMaxHealth;
          let pos = randomPosition();
          enemy.x = pos.x;
          enemy.y = pos.y;
          enemy.dirX = Math.random() < 0.5 ? -1 : 1;
          enemy.dirY = Math.random() < 0.5 ? -1 : 1;
          enemy.lastAttackTime = 0;
        }
        return;
      }

      // Move enemy slowly
      enemy.x += enemy.dirX * enemySpeed;
      enemy.y += enemy.dirY * enemySpeed;

      // Bounce off edges
      if(enemy.x < enemy.size/2 || enemy.x > canvas.width - enemy.size/2) enemy.dirX *= -1;
      if(enemy.y < enemy.size/2 || enemy.y > canvas.height - enemy.size/2) enemy.dirY *= -1;

      // Enemy attacks player if near and cooldown passed
      if(isNear(enemy, player, enemyAttackRange)) {
        if(timestamp - enemy.lastAttackTime > enemyAttackCooldown) {
          player.health -= enemyAttackDamage;
          enemy.lastAttackTime = timestamp;
          if(player.health <= 0) {
            player.alive = false;
          }
        }
      }

      // Draw enemy
      ctx.fillStyle = enemy.color;
      ctx.fillRect(enemy.x - enemy.size/2, enemy.y - enemy.size/2, enemy.size, enemy.size);

      // Draw enemy health bar above enemy
      drawHealthBar(enemy.x - enemy.size/2, enemy.y - enemy.size/2 - 10, enemy.size, 6, enemy.health, enemyMaxHealth, 'lime');
    });

    // Draw player
    ctx.fillStyle = player.color;
    ctx.fillRect(player.x - player.size/2, player.y - player.size/2, player.size, player.size);

    // Draw player health bar top left
    drawHealthBar(20, 20, 200, 20, player.health, player.maxHealth, '#00ff00');

    requestAnimationFrame(gameLoop);
  }

  requestAnimationFrame(gameLoop);
})();
</script>

</body>
</html>
